// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file vsc/oracle/v1/event.proto (package vsc.oracle.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { ExchangeRateTuple } from "./oracle_pb.js";

/**
 * Emitted when a price is posted
 *
 * @generated from message vsc.oracle.v1.EventPriceUpdate
 */
export class EventPriceUpdate extends Message<EventPriceUpdate> {
  /**
   * @generated from field: string pair = 1;
   */
  pair = "";

  /**
   * @generated from field: string price = 2;
   */
  price = "";

  /**
   * @generated from field: int64 timestamp_ms = 3;
   */
  timestampMs = protoInt64.zero;

  constructor(data?: PartialMessage<EventPriceUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "vsc.oracle.v1.EventPriceUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pair", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "timestamp_ms", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventPriceUpdate {
    return new EventPriceUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventPriceUpdate {
    return new EventPriceUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventPriceUpdate {
    return new EventPriceUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: EventPriceUpdate | PlainMessage<EventPriceUpdate> | undefined, b: EventPriceUpdate | PlainMessage<EventPriceUpdate> | undefined): boolean {
    return proto3.util.equals(EventPriceUpdate, a, b);
  }
}

/**
 * Emitted when a valoper delegates oracle voting rights to a feeder address.
 *
 * @generated from message vsc.oracle.v1.EventDelegateFeederConsent
 */
export class EventDelegateFeederConsent extends Message<EventDelegateFeederConsent> {
  /**
   * Validator is the Bech32 address that is delegating voting rights.
   *
   * @generated from field: string validator = 1;
   */
  validator = "";

  /**
   * Feeder is the delegate or representative that will be able to send
   * vote and prevote transaction messages.
   *
   * @generated from field: string feeder = 2;
   */
  feeder = "";

  constructor(data?: PartialMessage<EventDelegateFeederConsent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "vsc.oracle.v1.EventDelegateFeederConsent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "validator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "feeder", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventDelegateFeederConsent {
    return new EventDelegateFeederConsent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventDelegateFeederConsent {
    return new EventDelegateFeederConsent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventDelegateFeederConsent {
    return new EventDelegateFeederConsent().fromJsonString(jsonString, options);
  }

  static equals(a: EventDelegateFeederConsent | PlainMessage<EventDelegateFeederConsent> | undefined, b: EventDelegateFeederConsent | PlainMessage<EventDelegateFeederConsent> | undefined): boolean {
    return proto3.util.equals(EventDelegateFeederConsent, a, b);
  }
}

/**
 * Emitted by MsgAggregateExchangeVote when an aggregate vote is added to state
 *
 * @generated from message vsc.oracle.v1.EventAggregateVote
 */
export class EventAggregateVote extends Message<EventAggregateVote> {
  /**
   * Validator is the Bech32 address to which the vote will be credited.
   *
   * @generated from field: string validator = 1;
   */
  validator = "";

  /**
   * Feeder is the delegate or representative that will send vote and prevote
   * transaction messages on behalf of the voting validator.
   *
   * @generated from field: string feeder = 2;
   */
  feeder = "";

  /**
   * @generated from field: repeated vsc.oracle.v1.ExchangeRateTuple prices = 3;
   */
  prices: ExchangeRateTuple[] = [];

  constructor(data?: PartialMessage<EventAggregateVote>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "vsc.oracle.v1.EventAggregateVote";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "validator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "feeder", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "prices", kind: "message", T: ExchangeRateTuple, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventAggregateVote {
    return new EventAggregateVote().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventAggregateVote {
    return new EventAggregateVote().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventAggregateVote {
    return new EventAggregateVote().fromJsonString(jsonString, options);
  }

  static equals(a: EventAggregateVote | PlainMessage<EventAggregateVote> | undefined, b: EventAggregateVote | PlainMessage<EventAggregateVote> | undefined): boolean {
    return proto3.util.equals(EventAggregateVote, a, b);
  }
}

/**
 * Emitted by MsgAggregateExchangePrevote when an aggregate prevote is added
 * to state
 *
 * @generated from message vsc.oracle.v1.EventAggregatePrevote
 */
export class EventAggregatePrevote extends Message<EventAggregatePrevote> {
  /**
   * Validator is the Bech32 address to which the vote will be credited.
   *
   * @generated from field: string validator = 1;
   */
  validator = "";

  /**
   * Feeder is the delegate or representative that will send vote and prevote
   * transaction messages on behalf of the voting validator.
   *
   * @generated from field: string feeder = 2;
   */
  feeder = "";

  constructor(data?: PartialMessage<EventAggregatePrevote>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "vsc.oracle.v1.EventAggregatePrevote";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "validator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "feeder", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventAggregatePrevote {
    return new EventAggregatePrevote().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventAggregatePrevote {
    return new EventAggregatePrevote().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventAggregatePrevote {
    return new EventAggregatePrevote().fromJsonString(jsonString, options);
  }

  static equals(a: EventAggregatePrevote | PlainMessage<EventAggregatePrevote> | undefined, b: EventAggregatePrevote | PlainMessage<EventAggregatePrevote> | undefined): boolean {
    return proto3.util.equals(EventAggregatePrevote, a, b);
  }
}

/**
 * @generated from message vsc.oracle.v1.EventValidatorPerformance
 */
export class EventValidatorPerformance extends Message<EventValidatorPerformance> {
  /**
   * Validator is the Bech32 address to which the vote will be credited.
   *
   * @generated from field: string validator = 1;
   */
  validator = "";

  /**
   * Tendermint consensus voting power
   *
   * @generated from field: int64 voting_power = 2;
   */
  votingPower = protoInt64.zero;

  /**
   * RewardWeight: Weight of rewards the validator should receive in units of
   * consensus power.
   *
   * @generated from field: int64 reward_weight = 3;
   */
  rewardWeight = protoInt64.zero;

  /**
   * Number of valid votes for which the validator will be rewarded
   *
   * @generated from field: int64 win_count = 4;
   */
  winCount = protoInt64.zero;

  /**
   * Number of abstained votes for which there will be no reward or punishment
   *
   * @generated from field: int64 abstain_count = 5;
   */
  abstainCount = protoInt64.zero;

  /**
   * Number of invalid/punishable votes
   *
   * @generated from field: int64 miss_count = 6;
   */
  missCount = protoInt64.zero;

  constructor(data?: PartialMessage<EventValidatorPerformance>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "vsc.oracle.v1.EventValidatorPerformance";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "validator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "voting_power", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "reward_weight", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "win_count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "abstain_count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "miss_count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventValidatorPerformance {
    return new EventValidatorPerformance().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventValidatorPerformance {
    return new EventValidatorPerformance().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventValidatorPerformance {
    return new EventValidatorPerformance().fromJsonString(jsonString, options);
  }

  static equals(a: EventValidatorPerformance | PlainMessage<EventValidatorPerformance> | undefined, b: EventValidatorPerformance | PlainMessage<EventValidatorPerformance> | undefined): boolean {
    return proto3.util.equals(EventValidatorPerformance, a, b);
  }
}

